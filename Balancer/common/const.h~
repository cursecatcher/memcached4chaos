#ifndef CONS_H
#define CONS_H

#include <ctime>
#include <string.h>
#include <vector>
#include <msgpack.hpp>
#include "fullIpAddress.h"
//CLIENT flags
#define SERVER 0
#define GETTER 1
#define SETTER 2
//SERVER flags
#define OFFLINE 3
#define ONLINE 4
//misc
#define ERR -1
#define ACK 1
#define MIGRATE 2
#define STATUS_REQ 3
#define LIST_UPDATE 4

using namespace std;
// struct status is also used as bClient -> bServer and sClient -> sServer Greeting Message
// containing all the info about send/recv process: avgLoad (aka sClient pkgSize) and bandwidth ( 1000 / sClient.update_interval_param )
//
struct status{
	int type; // SERVER , SETTER or GETTER
	int port; // set by SERVER
	char name[32];  // for debug purpose
	int bandwidth; // Bytes/sec
	float avgLoad; // Bytes
};



// ---------------------------------------------
/*
struct fullIpAddress{
	char ip[16];
	int port;
};*/

// ---------------------------------------------

struct bClientStatus{ // used by sServer
// very similar to the status structure used by bClient and bServer, with the addition of the sending CLIENT's ip
// a bClientStatus wil be created for every incoming bClient connection, and appended to the respective list ( serverList orclientList )
	// status fields
	int type; // for CLIENT it can be GETTER or SETTER ; for SERVER it can be ONLINE(default) or OFFLINE(waiting to be up again)
	int port; // set by SERVER
	int bandwidth; // Bytes/sec
	float avgLoad; // Bytes
	char name[32];  // for debug purpose
	// added fields
	int csock; // socket connection number to the bClient
	char ip[16]; // its ip
	std::vector<fullIpAddress> list; 	//  case SERVER -> list of connected CLIENTs to restore in case of disconnection/reconnection
					//  case CLIENT -> balancedList of servers, with list[0] default SERVER to which migrate back in case of disconnection/reconnection
};


#endif
